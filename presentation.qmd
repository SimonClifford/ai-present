---
title: "An AI tool for Dementia"
#subtitle: "It's containers all the way down"
author: "Simon Clifford"
institute: "University of Cambridge"
date: "2024-10-24"
date-format: "Do MMMM YYYY"
format:
  revealjs: 
    slide-number: true
    chalkboard: 
      buttons: false
    preview-links: auto
    logo: "images/camb_logo_transparent.svg"
    css: styles.css
    theme: [sky,mytheme.scss]
    mermaid-format: svg
title-slide-attributes:
    data-background-image: images/intended_layout.svg
    data-background-size: "60%"
    data-background-repeat: repeat
    data-background-opacity: "0.5"
---

## What is AI Dementia?

::: {.notes}
The algorithm:
1. Takes a 3D brain scan (a magnetic resonance image, MRI).
2. Processes it to reduce it to only showing grey matter.
3. Obtains some cognitive scores, usually from a database.
4. Runs the fairly simply Python code to reduce all this to a single score.
:::

The method^1,2^
uses a machine learning (ML) algorithm trained on brain images (MRIs) and cognitive
scores to give a prognostic score of the likelihood of the patient having Alzheimer's.

::: footer
1: https://doi.org/10.1016/j.nicl.2020.102199

2: https://doi.org/10.1101/2020.08.15.252601
:::

```{mermaid}
%%| fig-width: 1000.0px
%%| fig-height: 400.0px
graph LR
A[Brain MRI] --> B[Gray Matter]
B --> C[ML Model]
D[Cognitive Scores] --> C
```

## The XNAT prototype
::: {.notes}
Inherited the project from an earlier incarnation developed by Piero and Matt.

XNAT is a research platform for importing and processing image data.  However, it's not generally deployed in clinical settings.
:::
![XNAT prototype, Coronica & Archer](images/Compute-output.jpeg)

## Structure of the prototype
::: {.notes}
The code has various scripts that fire on particular XNAT triggers to perform the
algorithm.

REDCap is a "secure web application for building online surveys and databases".
It provides an API for recovering previously entered data.  It's commmonly used
in clinical research settings.

The Docker container is where the ML code is.

But Stretch is no longer supported, SPM12 was last updated in Jan 2020, and
Matlab 2010a...  Alas, it turns out we don't have the Matlab source code, only
compiled `.mat` files, so we are stuck until our collaborators come up with the
source.
:::
```{mermaid}
%%| fig-width: 1000.0px
%%| fig-height: 400.0px
graph LR
A[XNAT server] --> B[Docker container]
A -.-> C[(REDCap server)]
```

The Docker container holds a
[Debian Stretch^2^ image]{.fragment .highlight-red} with [SPM12^3^]{.fragment
.highlight-red} and a [Matlab 2010a]{.fragment .highlight-red} runtime.  SPM is
a Matlab library for analysing brain images.

::: footer
1: https://projectredcap.org/

2: Debian Stretch June 2017 to June 2022, https://www.debian.org/releases/stretch/

3: https://www.fil.ion.ucl.ac.uk/spm/software/spm12/
:::

## Images
::: notes
1. Prototype was handed images
1. We need to get them in a hospital setting.
1. Needs to download image data from a Picture Archiving and Communication
Service (PACS).
1. DICOM (Digital Imaging and Communications in Medicine) started in the mid-_80's_.
:::

::: {.incremental}
- Where are clinical images stored in a hospital?
  - A PACS.
- What is a PACS?
  - Essentially a networked database.
- What does it speak?
  - DICOM.
    - Defines file format and transfer protocol.
    - _Really_ comprehensive metadata.
:::

## Images
::: notes
1. Note the Patient "Genetic Modifications Sequence" and "Species" information.
:::
![](images/dicom_example.png)

## Images

::: notes
1. We need for a user to be able to query a PACS for patient info, scan details,
and finally download data.
2. The prototype works on NIfTI images.  A format commonly used to store MRI
brain imaging data, popular with researchers, less so with clinicians.
3. The segmentation uses standard SPM12 functions to leave only grey matter.
:::
::: {.incremental}
- Use Pynetdicom^1^ to search for and download images.
- Use several tools to convert to NIfTI^2^ format.
- Use existing SPM12 container to segment into grey matter image.
  - Note this segmentation is _slow_!
:::

::: footer
1: https://pydicom.github.io/pynetdicom/stable/

2: Neuroimaging Informatics Technology Initiative: https://nifti.nimh.nih.gov/
:::

## Building upon the prototype
::: {.notes}
1. XNAT no good because not widely deployed in clinical settings.
1. Want some client-server structure.
1. ADVANCE.
1. First deployed in Addenbrooke's, then other Cambridge Trust hospital, finally
some third party.
1. Turns out hospitals are putting all their infra in this fancy fly-by-night
thing called the cloud.
1. And they don't want random researchers installing things into their web infra.
:::
The PIs want to take this from the prototype to something that can be used
in a clinical setting.

[![](images/AWEBAPP.gif)]{.fragment .fade-up}

::: {.incremental}
1. Everyone has a web browser, no need to worry about clients.
2. Established network protocol, security available.
3. [[Can install it into the existing hospital web infra.]{.fragment .strike}]{.fragment .semi-fade-out}
4. I've written web apps before.
:::

## Flask
::: notes
1. My favourite!
1. Flask doesn't require any particular database or structure.
1. Instead you add extensions for those things.
1. In the example explain this is the entire application. The decorator
registers the `hello_world` function to the `"/"` route.
1. When a request comes in on that route the function is run and its return
value sent back to the client.
1. Usually have Jinja templates (unless designing an API) which can do
Python-like logic.
:::
Flask^1^ is a lightweight and extendable web microframework.  

A (very) minimal application is:
```{.python}
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")
def hello_world():
    return "<p>Hello, World!</p>"

@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    return render_template('hello.html', person=name)
```
::: footer
1: https://flask.palletsprojects.com/
:::

## Flask App
So we wrote a fairly simple Flask app with the following routes:
```
Endpoint                  Methods    Rule
------------------------  ---------  -----------------------
auth.login                GET, POST  /login
main.home_page            GET        /
main.search_previous      GET, POST  /search_previous
main.select_patient       GET, POST  /select_patient
main.select_series        GET        /select_series
main.select_study         GET        /select_study
main.explain_no_config    GET        /explain_no_config
main.request_score        GET        /request_score
main.confirm_delete       GET        /confirm_delete
main.delete_request       GET        /delete_request
main.view_request         GET        /view_request
admin.add_user            GET, POST  /add_user
admin.admin_home_page     GET        /admin
admin.edit_configuration  GET, POST  /edit_configuration
admin.edit_user           GET, POST  /edit_user
admin.edit_users          GET        /edit_users
admin.view_logs           GET        /view_logs
static                    GET        /static/<path:filename>
```
::: notes
1. There's a login page that sets a local cookie once authenticated.  Handled by
a Flask extension, Flask-login.  All other routes are marked as "for logged in
users only".
1. The `main` routes allow the clinician to search a PACS for patients, then for
MRI studies for that patient, then download them.
1. Also to submit a request for a score calculation.
1. Forms go to `POST` routes, simplified by an extension, Flask-WTForms.
1. Finally some admin routes that are only available to users marked as "admin",
for adding users and so on.
:::

## Where to run the flask app?
::: {.incremental}
1. We don't want to run it inside the Docker container with the ancient Matlab,
Debian, etc, because that's old.
1. Don't want to assume what the client will have installed.
1. I know....
:::

::: {.fragment .fade-in}
::: {.r-fit-text}
Another Docker container!
:::
:::

## App design
```{mermaid}
%%| fig-width: 1000.0px
%%| fig-height: 400.0px
graph LR
A[Flask app container] --> B[ML container]
A -.-> C[(REDCap server)]
```

::: notes
1. The Flask app handles the users and interacts with the ML container and
the remote REDCap server.
:::

## Database
::: {.incremental}
- App will need users, authentication.
  - So needs somewhere to store usernames, hashes.
  - Also track the requests a clinician has made.
  - _Could_ use SQLite but gives problems later
  - Really like to use PostgreSQL
    - Have to assume user has it installed?
    - No...
:::

::: {.fragment .fade-in}
![](images/a_container.gif)
:::

::: notes
1. While it is possible to hook into SSO, etc, we will start with a local
authentication mechanism.
1. The clinician makes a request, we will need to store information like patient
details somewhere.
1. SQLite builtin to Python, nice database but it will prove problematic in later steps.
:::

## SQLAlchemy^1^

::: notes
1. SQLAlchemy is a Python SQL toolkit and Object Relational Manager.
1. Captures the description of each table in the DB in _Python_ code.
6. Only store the schema in one place.
2. Can automatically create the entire DB.  Extensions to migrate between versions.
3. Provides Pythonic way to address database joins.
4. So in example shown, each Request references a single User by its `id` (line 15).
5. By declaring a `relationship` (line 16) we can reference the User object that
the request is owned by directly.  We also use `back_populates` to get a list of
Requests that each User owns.  All accessing the database is lazy.
:::

::: {.fragment .fade-in}
```python
class User(UserMixin, db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(length=64), unique=True, index=True,
                         nullable=False)
    # as per https://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690
    email = db.Column(db.String(length=254))                     
    password_hash = db.Column(db.String(length=128), nullable=False)
    is_admin = db.Column(db.Boolean, nullable=False, default=False)
    requests = relationship('Request')

class Request(db.Model):

    id = db.Column(db.Integer, primary_key=True)  # internal ID
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    user = relationship('User', back_populates='requests')
    series_instance_uid = db.Column(db.String(length=64),
                                    nullable=False)  # UI
    patient_id = db.Column(db.Text, ForeignKey('patient.patient_id'),
                           nullable=False)  # LO
    patient = relationship('Patient')
    study_description = db.Column(db.Text)  # LO
    study_date = db.Column(db.Date)  # DA
    series_description = db.Column(db.Text)  # LO
    series_date = db.Column(db.Date)  # DA
    series_description = db.Column(db.Text)  # LO
    mr_scan_path = db.Column(db.Text)
    mr_scan_path_nifti = db.Column(db.Text)
    gm_scan_path = db.Column(db.Text)
    # will fix but currently scores parsed as
    # comma sep list by scripts
    score_data = db.Column(db.Text)
    # result_data stores JSON encoded result data.
    result_data = db.Column(db.Text, default='{}')
    request_date = db.Column(db.DateTime, server_default=func.now())
    result_date = db.Column(db.DateTime)
    # Choose 40 chars because we might use git commit SHAs as version
    # markers one day?
    result_version = db.Column(db.String(40))
    task_id = db.Column(db.String(36))
```
:::

::: {.footer}
1: https://www.sqlalchemy.org/
:::

## SQLAlchemy

::: notes
1. There's also a Flask-SQLAlchemy extension.
:::

```python
>>> simon = User.query.get(1)
>>> simon.username
'simon'
>>> simon.password_hash
'pbkdf2:sha256:600000$P950Nsh7qgGMblJB$8b247bac3ff808890f3bf4e316fdfa77ab03d749c534f6227d6dc6676275b60c'
>>> simon.requests
[<Request 4>, <Request 5>, <Request 6>]
```

## Segmentation slow
- Asynchronous web request
- User submits, goes away
- Req keeps going
- Celery!
  - But celery needs a broker.
  - Redis
  - Have to assume user has it installed?
  - No! Another container!

## Need SSL to keep secret
- WSGI hosters not always great at that
- Plus host may already do this
- Optional SSL bit then, reverse proxy, nginx
- WHERE CAN IT GO?

## What about testing?
- Can't test against live PACS, want to test PACS parts
- Mocking?  But this is the hard bit
- Could run a test PACS with safe data
- Oh ho ho

## docker-compose
- Show file
- Fun fact: docker compose inside a container will use the local container's `docker-compose.yml`
  but files referred to from that compose file are looked for _on the host_.